using JSON3: JSON3
using TOML: TOML
using Pkg
using Tar: Tar
using CodecZlib: GzipDecompressorStream
using DataStructures: OrderedDict as Dict

exists(advisory, key) = haskey(advisory, key) && is_populated(getproperty(advisory, key))
exists(advisory, key, keys...) = exists(advisory, key) && exists(advisory, keys...)
is_populated(::Nothing) = false
is_populated(::Missing) = false
is_populated(s::AbstractString) = !isempty(strip(s))
is_populated(A::AbstractArray) = !isempty(A)
is_populated(d::AbstractDict) = !isempty(d)
is_populated(::Any) = true

function get_registry(reg=Pkg.RegistrySpec(name="General", uuid = "23338594-aafe-5451-b93e-139f81909106"); depot=Pkg.depots1())
    name = joinpath(depot, "registries", reg.name)
    if !ispath(name) && !ispath(name * ".toml")
        Pkg.Registry.add([reg]; depot)
    end
    if !ispath(name)
        name = name * ".toml"
    end
    ispath(name) || error("Registry $name not found")
    return Pkg.Registry.RegistryInstance(name)
end

function uuids_from_name(name, reg=get_registry())
    Pkg.Registry.uuids_from_name(reg, name)
end
registry_has_package(name, reg=get_registry()) = !isempty(uuids_from_name(reg, name))

available_versions_for_uuid(uuid) = available_versions_for_uuid(Base.UUID(uuid))
function available_versions_for_uuid(uuid::Base.UUID, reg=get_registry())
    info = Pkg.Registry.registry_info(reg[uuid])
    return sort(collect(keys(info.version_info)))
end

function untar_readmes(tar_gz::AbstractString)
    data = String[]
    buf = Vector{UInt8}(undef, Tar.DEFAULT_BUFFER_SIZE)
    io = IOBuffer()
    open(tar_gz) do compressed_tar
        tar = GzipDecompressorStream(compressed_tar)
        Tar.read_tarball(x->contains(lowercase(x.path), "readme"), tar; buf=buf) do hdr, _
            if hdr.type == :file
                Tar.read_data(tar, io; size=hdr.size, buf=buf)
                push!(data, String(take!(io)))
            end
        end
    end
    return join(data, "\n")
end


function readme_for_pkg(name, uuid, version; reg=get_registry())
    # We intentionally side-step the package resolver here, but still lean on the Pkg server
    tree_hash = reg[uuid].info.version_info[version].git_tree_sha1
    server, _ = Pkg.Registry.pkg_server_registry_info()
    tarball = download("$server/package/$uuid/$tree_hash")
    return untar_readmes(tarball)
end

const CPE_CONFIG = Ref{Dict{String,Any}}()
cpe_config() = isdefined(CPE_CONFIG,1) ? CPE_CONFIG[] : (CPE_CONFIG[] = TOML.parsefile(joinpath(@__DIR__, "..", "cpe_config.toml")))
upstream_versions_for_package(pkgname) = Dict(string(v)=>upstream_versions_for_package(pkgname, v) for v in available_versions_for_uuid(only(uuids_from_name(pkgname))))
function upstream_versions_for_package(pkgname, version; force=false)
    cpe_map = TOML.parsefile(joinpath(@__DIR__, "..", "cpe_map.toml"))
    if !force && haskey(cpe_map, pkgname) && haskey(cpe_map[pkgname], version)
        return cpe_map[pkgname][string(version)]
    end
    config = cpe_config()
    # First check for overrides
    results = Dict{String, String}()
    if pkgname in keys(config["overrides"]) && string(version) in keys(config["overrides"][pkgname])
        merge!(results, config["overrides"][pkgname][string(version)])
    end
    # Then check for readme patterns
    uuid = only(uuids_from_name(pkgname))
    r = readme_for_pkg(pkgname, uuid, version)
    for (regex, cpe) in config["readme-regexes"]
        m = match(Regex(regex), r)
        isnothing(m) && continue
        results[cpe] = m.captures[1]
    end
    open("cpe_map.toml","w") do f
        println(f, "# This file is autogenerated; use cpe_config.toml to adjust it")
        haskey(cpe_map, pkgname) || (cpe_map[pkgname] = Dict{String, Any}())
        cpe_map[pkgname][string(version)] = results
        TOML.print(f, cpe_map, sorted=true)
    end
    return results
end

const AVAILABLE_CPES = Pair{String,String}[]
function available_cpes()
    if isempty(AVAILABLE_CPES)
        cpe_map = TOML.parsefile(joinpath(@__DIR__, "..", "cpe_map.toml"))
        for (pkg, vers) in cpe_map
            for cpe in unique(Iterators.flatten(keys.(values(vers))))
                push!(AVAILABLE_CPES, cpe => pkg)
            end
        end
        sort!(AVAILABLE_CPES)
    end
    return AVAILABLE_CPES
end
function related_julia_packages(description, vendorproducts)
    pkgs = String[]
    jlpkgs_mentioned = [m.captures[1] for m in eachmatch(r"\b(\w+)\.jl\b", description)]
    for (vendor, product) in vendorproducts
        cpe = string("cpe:2.3:a:", vendor, ":", product)
        append!(pkgs, available_cpes()[searchsorted(available_cpes(), cpe=>"", by=first)])
        if (contains(lowercase(vendor), "julia") || endswith(product, ".jl")) && registry_has_package(chopsuffix(product, ".jl"))
            push!(pkgs, chopsuffix(product, ".jl"))
        end
        for pkg in jlpkgs_mentioned
            pkg == chopsuffix(product, ".jl") && registry_has_package(pkg) && push!(pkgs, pkg)
        end
    end
    return unique(pkgs)
end

# TODO: use the above Pkg machinery for this, too
const ALL_PKGS = Pair{String,String}[]
function all_pkgs(toml_url = "https://github.com/JuliaRegistries/General/raw/refs/heads/master/Registry.toml")
    if isempty(ALL_PKGS)
        # This should really use Pkg APIs, but they are non-trivial and were hanging on GitHub Actions?
        registry = TOML.parsefile(download(toml_url))
        append!(ALL_PKGS, sort!([info["name"]=>uuid for (uuid, info) in registry["packages"]]))
    end
    return ALL_PKGS
end
function get_uuids_in_general(pkgname)
    pkgs = all_pkgs()
    idxs = searchsorted(pkgs, pkgname=>"", by=first)
    return last.(getindex.((pkgs,), idxs))
end
function all_jlls()
    pkgs = all_pkgs()
    filter(endswith("_jll")∘first, pkgs)
end

function get_packages(osv)
    pkgs = Tuple{String,String}[]
    id = osv.id
    println("Looking for Julia packages in $id")
    if haskey(osv, :affected) && !isempty(osv.affected)
        for vuln in osv.affected
            if haskey(vuln, :package) && haskey(vuln.package, :name) && haskey(vuln.package, :ecosystem)
                lowercase(string(vuln.package.ecosystem)) == "julia" || continue
                pkgname = chopsuffix(strip(vuln.package.name), ".jl")
                println(" - looking for $pkgname in the General registry")
                uuids = get_uuids_in_general(pkgname)
                if length(uuids) != 1
                    println(" ⨯ found $(length(uuids)) UUIDs for $pkgname")
                    create_issue(ENV["GITHUB_REPOSITORY"],
                        title="Failed to find a registered $(pkgname) for $is",
                        body="""
                            The advisory $id names **$pkgname** as an affected product from the
                            Julia ecosystem, but $(isempty(uuids) ? "no" : "more than one") match was found
                            in the General registry.

                            The complete OSV advisory is:

                            ```json
                            $(sprint((io,x)->JSON3.pretty(io, x, JSON3.AlignmentContext(indent=2)), osv))
                            ```
                            """
                    )
                else
                    println(" - found $pkgname => $(only(uuids))")
                    push!(pkgs, (pkgname, only(uuids)))
                end
            end
        end
    end
    return pkgs
end

function import_osv_files(path)
    packages_dir = "packages/General"
    n = 0
    for filename in readdir(path)
        endswith(filename, ".json") || continue

        osv_data = JSON3.read(joinpath(path, filename))

        for (package, uuid) in get_packages(osv_data)
            package_dir = joinpath(packages_dir, package)
            mkpath(package_dir)

            filename = "$(osv_data.id).json"
            filepath = joinpath(package_dir, filename)

            println("Writing advisory: $filepath")
            open(filepath, "w") do f
                JSON3.pretty(f, osv_data, JSON3.AlignmentContext(indent=2))
            end
            n += 1
        end
    end

    println("Completed writing $n advisories to disk")
end
